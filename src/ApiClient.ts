/**
 * Mailchimp Marketing API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 3.0.80
 * Contact: apihelp@mailchimp.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 *
 * Swagger Codegen version: 2.4.7
 *
 * Do not edit the class manually.
 *
 */

import superagent, { Response } from 'superagent';
import querystring from 'querystring';

import AccountExport from './api/AccountExportApi';
import AccountExports from './api/AccountExportsApi';
import ActivityFeed from './api/ActivityFeedApi';
import AuthorizedApps from './api/AuthorizedAppsApi';
import Automations from './api/AutomationsApi';
import BatchWebhooks from './api/BatchWebhooksApi';
import Batches from './api/BatchesApi';
import CampaignFolders from './api/CampaignFoldersApi';
import Campaigns from './api/CampaignsApi';
import ConnectedSites from './api/ConnectedSitesApi';
import Conversations from './api/ConversationsApi';
import CustomerJourneys from './api/CustomerJourneysApi';
import Ecommerce from './api/EcommerceApi';
import FacebookAds from './api/FacebookAdsApi';
import FileManager from './api/FileManagerApi';
import LandingPages from './api/LandingPagesApi';
import Lists from './api/ListsApi';
import Ping from './api/PingApi';
import Reporting from './api/ReportingApi';
import Reports from './api/ReportsApi';
import Root from './api/RootApi';
import SearchCampaigns from './api/SearchCampaignsApi';
import SearchMembers from './api/SearchMembersApi';
import Surveys from './api/SurveysApi';
import TemplateFolders from './api/TemplateFoldersApi';
import Templates from './api/TemplatesApi';
import VerifiedDomains from './api/VerifiedDomainsApi';

/**
 * @module ApiClient
 * @version 3.0.80
 */

/**
 * Manages low level client-server communications, parameter marshalling, etc. There should not be any need for an
 * application to use this class directly - the *Api and model classes provide the public API for the service. The
 * contents of this file should be regarded as internal but are documented for completeness.
 * @alias module:ApiClient
 * @class
 */
interface Config {
  apiKey: string;
  accessToken: string;
  server: string;
}

interface PathParams {
  [key: string]: any;
}

interface QueryParams {
  [key: string]: any;
}

interface HeaderParams {
  [key: string]: any;
}

interface FormParams {
  [key: string]: any;
}

interface ApiResponse<T> {
  data: T;
  response: Response;
}

class ApiClient {
  basePath: string;
  config: Config;
  defaultHeaders: Record<string, string>;
  timeout: number;
  cache: boolean;
  enableCookies: boolean;
  agent: superagent.SuperAgentStatic | null;
  accountExport: AccountExport;
  accountExports: AccountExports;
  activityFeed: ActivityFeed;
  authorizedApps: AuthorizedApps;
  automations: Automations;
  batchWebhooks: BatchWebhooks;
  batches: Batches;
  campaignFolders: CampaignFolders;
  campaigns: Campaigns;
  connectedSites: ConnectedSites;
  conversations: Conversations;
  customerJourneys: CustomerJourneys;
  ecommerce: Ecommerce;
  facebookAds: FacebookAds;
  fileManager: FileManager;
  landingPages: LandingPages;
  lists: Lists;
  ping: Ping;
  reporting: Reporting;
  reports: Reports;
  root: Root;
  searchCampaigns: SearchCampaigns;
  searchMembers: SearchMembers;
  surveys: Surveys;
  templateFolders: TemplateFolders;
  templates: Templates;
  verifiedDomains: VerifiedDomains;

  constructor() {
    this.basePath = 'https://server.api.mailchimp.com/3.0'.replace(/\/+$/, '');
    this.config = {
      apiKey: '',
      accessToken: '',
      server: 'invalid-server'
    };
    this.defaultHeaders = {};
    this.timeout = 120000;
    this.cache = true;
    this.enableCookies = false;
    this.agent = typeof window === 'undefined' ? new superagent.agent() : null;
    this.accountExport = new AccountExport(this);
    this.accountExports = new AccountExports(this);
    this.activityFeed = new ActivityFeed(this);
    this.authorizedApps = new AuthorizedApps(this);
    this.automations = new Automations(this);
    this.batchWebhooks = new BatchWebhooks(this);
    this.batches = new Batches(this);
    this.campaignFolders = new CampaignFolders(this);
    this.campaigns = new Campaigns(this);
    this.connectedSites = new ConnectedSites(this);
    this.conversations = new Conversations(this);
    this.customerJourneys = new CustomerJourneys(this);
    this.ecommerce = new Ecommerce(this);
    this.facebookAds = new FacebookAds(this);
    this.fileManager = new FileManager(this);
    this.landingPages = new LandingPages(this);
    this.lists = new Lists(this);
    this.ping = new Ping(this);
    this.reporting = new Reporting(this);
    this.reports = new Reports(this);
    this.root = new Root(this);
    this.searchCampaigns = new SearchCampaigns(this);
    this.searchMembers = new SearchMembers(this);
    this.surveys = new Surveys(this);
    this.templateFolders = new TemplateFolders(this);
    this.templates = new Templates(this);
    this.verifiedDomains = new VerifiedDomains(this);
  }

  /**
   * Sets the API configuration settings object.
   * @param config {Object} The configuration object
   */
  setConfig(config: Partial<Config> = {}): void {
    this.config = { ...this.config, ...config };
  }

  /**
   * Returns a string representation for an actual parameter.
   * @param param The actual parameter.
   * @returns {String} The string representation of <code>param</code>.
   */
  paramToString(param: any): string {
    if (param == undefined || param == null) {
      return '';
    }
    if (param instanceof Date) {
      return param.toJSON();
    }
    return param.toString();
  }

  /**
   * Builds full URL by appending the given path to the base URL and replacing path parameter place-holders with parameter values.
   * NOTE: query parameters are not handled here.
   * @param {String} path The path to append to the base URL.
   * @param {Object} pathParams The parameter values to append.
   * @returns {String} The encoded path with parameter values substituted.
   */
  buildUrl(path: string, pathParams: PathParams): string {
    if (!path.match(/^\//)) {
      path = '/' + path;
    }
    let url = this.basePath + path;
    url = url.replace(/\{([\w-]+)\}/g, (fullMatch, key) => {
      const value = pathParams.hasOwnProperty(key) ? this.paramToString(pathParams[key]) : fullMatch;
      return encodeURIComponent(value);
    });

    if (typeof this.config.server !== 'undefined') {
      url = url.replace('server', this.config.server);
    }

    return url;
  }

  /**
   * Checks whether the given content type represents JSON.<br>
   * JSON content type examples:<br>
   * <ul>
   * <li>application/json</li>
   * <li>application/json; charset=UTF8</li>
   * <li>APPLICATION/JSON</li>
   * </ul>
   * @param {String} contentType The MIME content type to check.
   * @returns {Boolean} <code>true</code> if <code>contentType</code> represents JSON, otherwise <code>false</code>.
   */
  isJsonMime(contentType: string): boolean {
    return Boolean(contentType != null && contentType.match(/^application\/json(;.*)?$/i));
  }

  /**
   * Chooses a content type from the given array, with JSON preferred; i.e. return JSON if included, otherwise return the first.
   * @param {Array.<String>} contentTypes
   * @returns {String} The chosen content type, preferring JSON.
   */
  jsonPreferredMime(contentTypes: string[]): string {
    for (const contentType of contentTypes) {
      if (this.isJsonMime(contentType)) {
        return contentType;
      }
    }
    return contentTypes[0];
  }

  /**
   * Checks whether the given parameter value represents file-like content.
   * @param param The parameter to check.
   * @returns {Boolean} <code>true</code> if <code>param</code> represents a file.
   */
  isFileParam(param: any): boolean {
    if (typeof require === 'function') {
      let fs;
      try {
        fs = require('fs');
      } catch (err) { }
      if (fs && fs.ReadStream && param instanceof fs.ReadStream) {
        return true;
      }
    }
    if (typeof Buffer === 'function' && param instanceof Buffer) {
      return true;
    }
    if (typeof Blob === 'function' && param instanceof Blob) {
      return true;
    }
    if (typeof File === 'function' && param instanceof File) {
      return true;
    }
    return false;
  }

  /**
   * Normalizes parameter values:
   * <ul>
   * <li>remove nils</li>
   * <li>keep files and arrays</li>
   * <li>format to string with `paramToString` for other cases</li>
   * </ul>
   * @param {Object.<String, Object>} params The parameters as object properties.
   * @returns {Object.<String, Object>} normalized parameters.
   */
  normalizeParams(params: Record<string, any>): Record<string, any> {
    const newParams: Record<string, any> = {};
    for (const key in params) {
      if (params.hasOwnProperty(key) && params[key] != undefined && params[key] != null) {
        const value = params[key];
        if (this.isFileParam(value) || Array.isArray(value)) {
          newParams[key] = value;
        } else {
          newParams[key] = this.paramToString(value);
        }
      }
    }
    return newParams;
  }

  /**
   * Enumeration of collection format separator strategies.
   * @enum {String}
   * @readonly
   */
  static CollectionFormatEnum = {
    /**
     * Comma-separated values. Value: <code>csv</code>
     * @const
     */
    CSV: ',',
    /**
     * Space-separated values. Value: <code>ssv</code>
     * @const
     */
    SSV: ' ',
    /**
     * Tab-separated values. Value: <code>tsv</code>
     * @const
     */
    TSV: '\t',
    /**
     * Pipe(|)-separated values. Value: <code>pipes</code>
     * @const
     */
    PIPES: '|',
    /**
     * Native array. Value: <code>multi</code>
     * @const
     */
    MULTI: 'multi'
  } as const;

  /**
   * Builds a string representation of an array-type actual parameter, according to the given collection format.
   * @param {Array} param An array parameter.
   * @param {module:ApiClient.CollectionFormatEnum} collectionFormat The array element separator strategy.
   * @returns {String|Array} A string representation of the supplied collection, using the specified delimiter. Returns
   * <code>param</code> as is if <code>collectionFormat</code> is <code>multi</code>.
   */
  buildCollectionParam(param: any[], collectionFormat: keyof typeof ApiClient.CollectionFormatEnum): string | any[] {
    if (param == null) {
      return null;
    }
    switch (collectionFormat) {
      case 'csv':
        return param.map(this.paramToString).join(',');
      case 'ssv':
        return param.map(this.paramToString).join(' ');
      case 'tsv':
        return param.map(this.paramToString).join('\t');
      case 'pipes':
        return param.map(this.paramToString).join('|');
      case 'multi':
        return param.map(this.paramToString);
      default:
        throw new Error('Unknown collection format: ' + collectionFormat);
    }
  }

  /**
   * Deserializes an HTTP response body into a value of the specified type.
   * @param {Object} response A SuperAgent response object.
   * @param {(String|Array.<String>|Object.<String, Object>|Function)} returnType The type to return. Pass a string for simple types
   * or the constructor function for a complex type. Pass an array containing the type name to return an array of that type. To
   * return an object, pass an object with one property whose name is the key type and whose value is the corresponding value type:
   * all properties on <code>data<code> will be converted to this type.
   * @returns A value of the specified type.
   */
  deserialize<T>(response: Response, returnType: any): T | null {
    if (response == null || returnType == null || response.status == 204) {
      return null;
    }
    let data = response.body;
    if (data == null || (typeof data === 'object' && typeof data.length === 'undefined' && !Object.keys(data).length)) {
      data = response.text;
    }
    return ApiClient.convertToType(data, returnType);
  }

  /**
   * Invokes the REST service using the supplied settings and parameters.
   * @param {String} path The base URL to invoke.
   * @param {String} httpMethod The HTTP method to use.
   * @param {Object.<String, String>} pathParams A map of path parameters and their values.
   * @param {Object.<String, Object>} queryParams A map of query parameters and their values.
   * @param {Object.<String, Object>} headerParams A map of header parameters and their values.
   * @param {Object.<String, Object>} formParams A map of form parameters and their values.
   * @param {Object} bodyParam The value to pass as the request body.
   * @param {Array.<String>} authNames An array of authentication type names.
   * @param {Array.<String>} contentTypes An array of request MIME types.
   * @param {Array.<String>} accepts An array of acceptable response MIME types.
   * @param {(String|Array|ObjectFunction)} returnType The required type to return; can be a string for simple types or the
   * constructor for a complex type.
   * @returns {Promise} A {@link https://www.promisejs.org/|Promise} object.
   */
  callApi<T>(
    path: string,
    httpMethod: string,
    pathParams: PathParams,
    queryParams: QueryParams,
    headerParams: HeaderParams,
    formParams: FormParams,
    bodyParam: any,
    authNames: string[],
    contentTypes: string[],
    accepts: string[],
    returnType: any
  ): Promise<ApiResponse<T>> {
    const url = this.buildUrl(path, pathParams);
    const request = superagent(httpMethod, url);

    if (this.config.apiKey !== undefined && this.config.apiKey !== '') {
      request.auth('user', this.config.apiKey);
    } else if (this.config.accessToken !== undefined && this.config.accessToken !== '') {
      request.set({ Authorization: 'Bearer ' + this.config.accessToken });
    }

    if (httpMethod.toUpperCase() === 'GET' && this.cache === false) {
      queryParams['_'] = new Date().getTime();
    }
    request.query(this.normalizeParams(queryParams));
    request.set(this.defaultHeaders).set(this.normalizeParams(headerParams));
    request.timeout(this.timeout);

    const contentType = this.jsonPreferredMime(contentTypes);
    if (contentType) {
      if (contentType != 'multipart/form-data') {
        request.type(contentType);
      }
    } else if (!request.header['content-type']) {
      request.type('application/json');
    }

    if (contentType === 'application/x-www-form-urlencoded') {
      request.send(querystring.stringify(this.normalizeParams(formParams)));
    } else if (contentType == 'multipart/form-data') {
      const _formParams = this.normalizeParams(formParams);
      for (const key in _formParams) {
        if (_formParams.hasOwnProperty(key)) {
          if (this.isFileParam(_formParams[key])) {
            request.attach(key, _formParams[key]);
          } else {
            request.field(key, _formParams[key]);
          }
        }
      }
    } else if (bodyParam) {
      request.send(bodyParam);
    }

    const accept = this.jsonPreferredMime(accepts);
    if (accept) {
      request.accept(accept);
    }

    if (returnType === 'Blob') {
      request.responseType('blob');
    } else if (returnType === 'String') {
      request.responseType('string');
    }

    if (this.enableCookies) {
      if (typeof window === 'undefined') {
        this.agent?.attachCookies(request);
      } else {
        request.withCredentials();
      }
    }

    return new Promise((resolve, reject) => {
      request.end((error, response) => {
        if (error) {
          reject(error);
        } else {
          try {
            const data = this.deserialize<T>(response, returnType);
            if (this.enableCookies && typeof window === 'undefined') {
              this.agent?.saveCookies(response);
            }
            resolve({ data, response });
          } catch (err) {
            reject(err);
          }
        }
      });
    });
  }

  /**
   * Parses an ISO-8601 string representation of a date value.
   * @param {String} str The date value as a string.
   * @returns {Date} The parsed date object.
   */
  static parseDate(str: string): Date {
    return new Date(str.replace(/T/i, ' '));
  }

  /**
   * Converts a value to the specified type.
   * @param {(String|Object)} data The data to convert, as a string or object.
   * @param {(String|Array.<String>|Object.<String, Object>|Function)} type The type to return. Pass a string for simple types
   * or the constructor function for a complex type. Pass an array containing the type name to return an array of that type. To
   * return an object, pass an object with one property whose name is the key type and whose value is the corresponding value type:
   * all properties on <code>data<code> will be converted to this type.
   * @returns An instance of the specified type or null or undefined if data is null or undefined.
   */
  static convertToType<T>(data: any, type: any): T {
    if (data === null || data === undefined) return data;

    switch (type) {
      case 'Boolean':
        return Boolean(data) as unknown as T;
      case 'Integer':
        return parseInt(data, 10) as unknown as T;
      case 'Number':
        return parseFloat(data) as unknown as T;
      case 'String':
        return String(data) as unknown as T;
      case 'Date':
        return this.parseDate(String(data)) as unknown as T;
      case 'Blob':
        return data as T;
      default:
        if (type === Object) {
          return data as T;
        } else if (typeof type === 'function') {
          return type.constructFromObject(data) as T;
        } else if (Array.isArray(type)) {
          const itemType = type[0];
          return data.map((item: any) => ApiClient.convertToType(item, itemType)) as unknown as T;
        } else if (typeof type === 'object') {
          const result: any = {};
          for (const k in data) {
            if (data.hasOwnProperty(k)) {
              const key = ApiClient.convertToType(k, Object.keys(type)[0]);
              const value = ApiClient.convertToType(data[k], Object.values(type)[0]);
              result[key] = value;
            }
          }
          return result as T;
        } else {
          return data as T;
        }
    }
  }

  /**
   * Constructs a new map or array model from REST data.
   * @param data {Object|Array} The REST data.
   * @param obj {Object|Array} The target object or array.
   */
  static constructFromObject<T>(data: any, obj: T, itemType: any): void {
    if (Array.isArray(data)) {
      for (let i = 0; i < data.length; i++) {
        if (data.hasOwnProperty(i)) obj[i] = ApiClient.convertToType(data[i], itemType);
      }
    } else {
      for (const k in data) {
        if (data.hasOwnProperty(k)) obj[k] = ApiClient.convertToType(data[k], itemType);
      }
    }
  }

  /**
   * The default API client implementation.
   * @type {module:ApiClient}
   */
  static instance = new ApiClient();
}

export default ApiClient;
